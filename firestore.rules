rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ======================
    // Helper Functions
    // ======================
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isAdmin() {
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    // ======================
    // Core Collections Rules
    // ======================
    
    // Users Collection - Simplified for Google Sign-In
    match /users/{userId} {
      // Allow authenticated users to read either:
      // - their own profile by UID, or
      // - any profile whose email matches their signed-in Google email, or
      // - an unclaimed pre-seeded record (uid is not yet set/empty) to support first-time claim by ID code
      // - other users in the same team (for team collaboration)
      allow read: if isSignedIn() && (
        request.auth.uid == userId ||
        resource.data.email == request.auth.token.email ||
        resource.data.uid == null || resource.data.uid == '' ||
        (
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.team == resource.data.team
        )
      );
      
      // Allow any authenticated user to create their own profile during ID code claim
      // This supports the ID code claim flow where a user creates their profile after Google sign-in
      // Temporarily more permissive to debug permission issues
      allow create: if isSignedIn();
      
      // Allow users to update their own profile OR perform a safe one-time claim on a pre-seeded record.
      // Claim cases supported:
      // 1) Both `email` and `uid` are unset: allow setting both to caller's values
      // 2) `email` is already set to caller's email and `uid` is unset: allow setting only `uid`
      // 3) New user creation during ID code claim (document doesn't exist yet)
      allow update: if isSignedIn() && (
        // Caller owns the profile by UID
        request.auth.uid == userId ||
        // Claiming a pre-seeded record
        (
          (resource.data.uid == null || resource.data.uid == '') && (
            // Case 1: set both uid and email when both are unset
            (
              (resource.data.email == null || resource.data.email == '') &&
              request.resource.data.diff(resource.data).changedKeys().hasOnly(['uid', 'email']) &&
              request.resource.data.uid == request.auth.uid &&
              request.resource.data.email == request.auth.token.email
            ) ||
            // Case 2: set only uid when email already matches caller
            (
              resource.data.email == request.auth.token.email &&
              request.resource.data.diff(resource.data).changedKeys().hasOnly(['uid']) &&
              request.resource.data.uid == request.auth.uid
            )
          )
        )
      );
      
      // Allow admin to manage all users
      allow read, write: if isAdmin();
    }
    
    // ID Code Verification Collection
    match /id_codes/{codeId} {
      // Admins can manage all codes
      allow read, write: if isAdmin();

      // Allow unauthenticated users to verify a specific code by ID
      // (Only document GETs; listing the collection still requires admin)
      allow get: if true;

      // Allow a one-time client-side claim of an unused code
      // Only the following fields may be updated: used, claimedByUid, claimedByEmail, claimedAt
      // Must set used=true and claim must match the caller's identity
      allow update: if isSignedIn() &&
                    (resource.data.used == false || resource.data.used == null) &&
                    request.resource.data.used == true &&
                    request.resource.data.claimedByUid == request.auth.uid &&
                    request.resource.data.claimedByEmail == request.auth.token.email &&
                    request.resource.data.diff(resource.data).changedKeys().hasOnly(['used', 'claimedByUid', 'claimedByEmail', 'claimedAt']);
    }
    
    // Teams Collection - SIMPLIFIED
    match /teams/{teamId} {
      // Admins have full access
      allow read, write: if isAdmin();
      
      // ANY signed-in user can read teams
      allow read: if isSignedIn();
      
      // Only admins can modify teams
      allow create, update, delete: if isAdmin();
    }
    
    // Allow listing teams collection for active users
    match /teams {
      allow list: if isSignedIn();
    }
    
    // Allow listing users collection for team members
    match /users {
      allow list: if isSignedIn();
    }
    
    // Projects Collection - SIMPLIFIED
    match /projects/{projectId} {
      // Admins have full access
      allow read, write: if isAdmin();
      
      // ANY signed-in user can read projects
      allow read: if isSignedIn();
      
      // Users can create projects
      allow create: if isSignedIn();
      
      // Users can update projects they are assigned to
      allow update: if isSignedIn() && 
                   request.auth.uid in resource.data.assignedTo;
    }
    
    // Allow listing projects collection for active users
    // This is needed for the useCollection hook to work properly
    match /projects {
      allow list: if isSignedIn();
    }
    
    // Announcements Collection - SIMPLIFIED
    match /announcements/{announcementId} {
      // Admins have full access
      allow read, write: if isAdmin();
      
      // ANY signed-in user can read announcements
      allow read: if isSignedIn();
      
      // Only admins can create, update, or delete announcements
      allow create, update, delete: if isAdmin();
    }
    
    // Allow listing announcements collection for active users
    match /announcements {
      allow list: if isSignedIn();
    }
    
    // Wiki Documents Collection - SIMPLIFIED
    match /wiki_docs/{docId} {
      // Admins have full access
      allow read, write: if isAdmin();
      
      // ANY signed-in user can read wiki docs
      allow read: if isSignedIn();
      
      // Only admins can modify wiki docs
      allow create, update, delete: if isAdmin();
    }
    
    // Allow listing wiki docs collection for active users
    match /wiki_docs {
      allow list: if isSignedIn();
    }
    
    // System Collections (Restricted Access)
    match /system_settings/{settingId} {
      allow read, write: if isAdmin();
    }
    
    match /audit_logs/{logId} {
      allow read: if isAdmin();
      allow create: if false; // Only via Cloud Functions
    }
    
    // ======================
    // Onboarding Flow Support
    // ======================
    
    // Contracts Collection - For storing signed contracts
    match /contracts/{contractId} {
      // Admins can read and manage all contracts
      allow read, write: if isAdmin();
      
      // Users can read their own contracts
      allow read: if isSignedIn() && resource.data.uid == request.auth.uid;
      
      // Users can create their own contracts during onboarding
      allow create: if isSignedIn() && 
                   request.resource.data.uid == request.auth.uid;
      
      // Users can update their own contracts (e.g., status updates)
      allow update: if isSignedIn() && 
                   resource.data.uid == request.auth.uid;
    }
    
    // Allow listing contracts collection for signed-in users
    match /contracts {
      allow list: if isSignedIn();
    }
    
    match /pending_registrations/{docId} {
      // Anyone can create a pending registration
      allow create: if true;
      
      // Admins can read all pending
      allow read: if isAdmin();
      
      // Users can read their own pending registration
      allow read: if isSignedIn() && resource.data.email == request.auth.token.email;
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
    
    // ======================
    // Default Deny Rule
    // ======================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}